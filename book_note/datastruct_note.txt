Chapter 1

1.1 数据结构
	1. 数据
	2. 数据元素：数据的基本单位，由若干个数据项组成		eg. 数据表中的一个记录
	3. 数据项（字段Field，域Domain）：不可分割的、含有独立意义的最小数据单位				
	   eg. 记录中学生的学号、成绩等等
	4. 数据对象
	5. 数据类型		eg. int float……
	6. 数据结构：数据元素的有限集合和数据元素间关系的有限集合
		1. 集合
		2. 线性
		3. 树形
		4. 图状
		－－－－－
		1. 逻辑结构（下称LS）：抽象的数学模型
		2. 物理结构（存储结构）（下称PS）：在计算机中表示和存储的方式
			1. 顺序存储		eg. 数组
			2. 链式存储		eg. 链表
			
1.2 算法：对某一特定类型的问题的求解步骤的一种描述，是指令的有限序列
	1. 特性：
		1. 有穷性(Finity)
		2. 确定性(Unambiguousness)
		3. 输入(Input)
		4. 输出(Output)
		5. 能行性(realizability)
	2. 评价标准
		1. 正确性(Correctness)
		2. 可读性(Readability)
		3. 健壮性(Robustness)
		4. 运行时间(Running Time)：时间复杂度
				通常把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度，
				其中基本操作一般是指算法中最深层循环内的语句
				记作：T(n)=O(f(n))	其中“O”符号表示数量级的概念
		5. 占用空间(Storage Space)：空间复杂度
		
1.3 数学预备知识
	1. 集合
	2. 常用术语
		取下整(Floor)：返回不超过x的最大整数
		和取上整(Ceiling)：返回不小于x的最大整数
	3. 对数
	4. 递归
		1. 直接递归
		2. 间接递归
		－－－－－－－－
		必须包含的2部分
			1.初始部分(Base Case)：只处理可以直接解决而不需要再次递归调用的简单输入
			2.递归部分(Recursion Case)：对算法的一次或多次递归调用，每一次的调用参数
										都在某种程度上比原始调用参数更接近初始情况
										
1.4 C#的预备知识
	1. 接口
	2. 泛型编程
		主要思想：将算法与数据结构完全分离开来，使得一次定义的算法能够作用于多种数据
				  结构，从而实现高度可重用的开发
					
=========================================================================================================
Chapter 2 线性表

定义：n(n≥0)个相同类型的数据元素构成的有限序列
	1. 数组
	2. 链表
		1. 单链表
		2. 双链表
		3. 循环链表
		
=========================================================================================================
Chapter 3 栈和队列

1. 栈(Stack)
	1. 定义：操作限定在表的尾端进行的线性表。表尾称为栈顶，表头称为栈底
	
2. 队列(Queue)
	1. 定义：插入操作限定在表的尾部而其它操作限定在表的头部进行的线性表。
			 表尾称为队尾(Rear)，表头称为队头(Front)
	2. 分类
		1. 顺序队列
		2. 循环队列
		
=========================================================================================================
Chapter 4 串和数组

1. 串(string)
	1. 定义：由n(n≥0)字符组成的有限序列。
			 一般记为：S=”c1c2…cn” (n≥0)
	2. 基本操作
		1. 求串长
		2. 串比较
		3. 求子串
		4. 串连接
		5. 串插入
		6. 串删除
		7. 串定位
		
2. 数组(array)
	1. 定义：
	2. 基本操作	
		1、取值操作：给定一组下标，读其对应的数据元素；
		2、赋值操作：给定一组下标，存储或修改与其对应的数据元素；
		3、清空操作：将数组中的所有数据元素清除；
		4、复制操作：将一个数组的数据元素赋给另外一个数组；
		5、排序操作：对数组中的数据元素进行排序，这要求数组中的数据元素是可排序的；
		6、反转操作：反转数组中数据元素的顺序。
	3. 内存映象(即PS)
		1. 一维数组：计算机的内存是一个一维数组，内存地址就是数组的下标。所以，
					 对于一维数组，可根据数组元素的下标得到它的存储地址，也可根据下标
					 来访问一维数组中的元素
		2. 二维数组：
			1. 先行后列		eg. a11, a12, a13...a21, a22, a23 ...
			2. 先列后行		eg. a11, a21, a31...a12, a22, a32 ...
			
=========================================================================================================
Chapter 5 树与二叉树

1. 树(Tree)
	1. 定义：由n(n≥0)个相同类型的数据元素组成的有限集合。
	         树中的数据元素叫结点(Node)。n=0的树称为空树(Empty Tree)；对于n＞0的任意非空树T有：
			（1）有且仅有一个特殊的结点称为树的根(Root)结点，根没有前驱结点；
			（2）若n＞1，则除根结点外，其余结点被分成了m(m＞0)个互不相交的集合T1，T2，…，Tm，
			     其中每一个集合Ti(1≤i≤m)本身又是一棵树。树T1，T2，…，Tm称为这棵树的子树(Subtree)。
	2. 相关术语
		1. 结点(Node)
		2. 结点的度(Degree of Node)：结点所拥有的子树的个数
		3. 树的度(Degree of Tree)：树中各结点度的最大值
		4. 叶子结点(Leaf Node)：度为0的结点，也叫终端结点
		5. 分支结点(Branch Node)：度不为0的结点
		6. 孩子(Child)
		7. 双亲(Parent)：结点的上层结点叫该结点的双亲
		8. 祖先(Ancestor)：从根到该结点所经分支上的所有结点
		9. 子孙(Descendant)：以某结点为根的子树中的任一结点
		10. 兄弟(Brother)：同一双亲的孩子
		11. 结点的层次(Level of Node)
		12. 堂兄弟(Sibling)：同一层的双亲不同的结点
		13. 树的深度(Depth of Tree)：树中结点的最大层次数
		14. 无序树(Unordered Tree)：
		15. 有序树(Ordered Tree)
		16. 森林(Forest)：m(m≥0)棵树的集合
	3. 基本操作
		1、Root()：求树的根结点，如果树非空，返回根结点，否则返回空；
		2、Parent(t)：求结点t的双亲结点。如果t的双亲结点存在，返回双亲结点，否则返回空；
		3、Child(t,i)：求结点t的第i个子结点。如果存在，返回第i个子结点，否则返回空；
		4、RightSibling(t)：求结点t第一个右边兄弟结点。如果存在，返回第一个右边兄弟结点，否则返回空；
		5、Insert(s,t,i)：把树s插入到树中作为结点t的第i棵子树。成功返回true，否则返回false；
		6、Delete(t,i)：删除结点t的第i棵子树。成功返回第i棵子树的根结点，否则返回空；
		7、Traverse(TraverseType)：按某种方式遍历树；
		8、Clear()：清空树；
		9、IsEmpty()：判断树是否为空树。如果是空树，返回true，否则返回false；
		10、GetDepth()：求树的深度。如果树不为空，返回树的层次，否则返回0。
			
2. 二叉树(Binary Tree)
	1. 定义：n(n≥0)个相同类型的结点的有限集合
			 二叉树是一种特殊的树，每个节点有且仅有2个子树
	2. 特殊的种类
		1. 满二叉树
		2. 完全二叉树
	3. 性质
	4. 存储结构
		1. 顺序存储结构：从上往下，从左至右，从根结点依次存储的方式
			1. 完全二叉树：ABCDEF……
			2. 非完全二叉树：ABC^D^E……
			   其中：^代表空出的空间
			顺序存储结构对非完全二叉树会造成极大的空间浪费，大约有一半
		2. 二叉链表存储结构：一个结点有3部分组成，1个数据域，2个引用域（left/right child）
		3. 三叉链表存储结构：一个结点有4部分组成，1个数据域，3个引用域（left/right child、parent）
			
3. 树和森林
	1. 树的遍历
		1. 先序遍历
		2. 后序遍历
		
4. 哈夫曼树(Huffman Tree)
	1. 定义：又叫最优二叉树，指的是对于一组具有确定权值的叶子结点的具有最小带权路径长度的二叉树
	2. 基本概念
		1. 路径(Path)：从树中的一个结点到另一个结点之间的分支构成这两个结点间的路径
		2. 路径长度(Path Length)：路径上的分支数
		3. 树的路径长度(Path Length of Tree)：从树的根结点到每个结点的路径长度之和
		4. 结点的权(Weight of Node)：在一些应用中，赋予树中结点的一个有实际意义的数
		5. 结点的带权路径长度(Weight Path Length of Node)：从该结点到树的根结点的路径长度与该结点的权的乘积
		6. 树的带权路径长度（WPL）：树中所有叶子结点的带权路径长度之和
	3. 哈夫曼算法：构造一棵哈夫曼树
		（1）根据给定的n个权值{w1,w2,…,wn}，构造n棵只有根结点的二叉树集合F={T1,T2,…,Tn}；
		（2）从集合F中选取两棵根结点的权最小的二叉树作为左右子树，构造一棵新的二叉树，且置新的二叉树的根结点的
			 权值为其左、右子树根结点权值之和。
		（3）在集合F中删除这两棵树，并把新得到的二叉树加入到集合F中；
		（4）重复上述步骤，直到集合中只有一棵二叉树为止，这棵二叉树就是哈夫曼树。
	4. 哈夫曼编码
		1. 定义：规定哈夫曼树中的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列
				 便为该结点对应字符的编码就是哈夫曼编码(Huffman Encoding)
		2. 用途：在数据通信中，通常需要把要传送的文字转换为由二进制字符0和1组成的二进制串，这个过程被称之为编码(Encoding)。
				 哈夫曼树可用于构造总长度最短的编码方案。
	
=========================================================================================================
Chapter 6 图

1. 基本概念	
	1. 定义：图(Graph)是由非空的顶点（Vertex）集合和描述顶点之间的关系——边（Edge）或弧（Arc）的集合组成。
			 形式化定义为：
				G=（V，E）
				V={vi|vi∈某个数据元素集合}
				E={(vi,vj)|vi,vj∈V∧P(vi,vj)}或E={<vi,vj>|vi,vj∈V∧P(vi,vj)}
			 其中，G表示图
				   V是顶点的集合（数据元素）
				   E是边或弧的集合（数据元素间的关系）
	2. 术语
		1. 无向图：顶点之间的连线没有方向
		2. 有向图：顶点之间的连线有方向
		3. 边、弧、弧头、弧尾
				边：无向图中2个顶点间的连线
				弧：有向图中2个顶点间的连线
				弧头：带箭头的一端
				弧尾：不带箭头的一端
		4. 无向完全图：任意2个顶点间有边相连
		5. 有向完全图：任意2个顶点间有边相连
		6. 顶点的度、入度、出度
				度：顶点v的度（Degree）是指依附于顶点v的边数，通常记为TD(v)
				入度：在有向图中，以该顶点v为弧头的弧的数目，记为ID(v)
				出度：在有向图中，以该顶点v为弧尾的弧的数目，记为OD(v)
		7. 权、网
				权：有些图的边（或弧）附带有一些数据信息，这些数据信息称为边（或弧）的权（Weight）
				网：边（或弧）上带权的图称为网或网络（Network）	
		8. 子图：设有两个图G1=（V1，E1），G2=（V2，E2），如果 V1是V2子集，E1也是E2的子集，
				 则称图G1是G2的子图(Subgraph)。
		9. 路径、路径长度
				路径
				路径长度：路径上边或弧的数目
		10. 简单路径、回路、简单回路
				简单路径：一条路径上顶点不重复出现
				回路：第一个顶点和最后一个顶点相同的路径
				简单回路：除第一个顶点和最后一个顶点相同其余顶点都不重复的回路
		11. 连通、连通图、连通分量
				连通：在无向图中，若两个顶点之间有路径，则称这两个顶点是连通的(Connect)
				连通图：在无向图中，任意两个顶点之间都是连通的
				连通分量：是无向图G的极大连通子图。极大连通子图是一个图的连通子图，该子图不是该图的
						  其它连通子图的子图
		12. 强连通图、强连通分量
				强连通图(Strongly Connected Graph)：在有向图中，若图中任意两个顶点之间都存在从一个顶点到另一个顶点的路径
				强连通分量(Strongly Connected Component)：有向图的极大强连通子图称为强连通分量。极大强连通子图是一个有向图
														  的强连通子图，该子图不是该图的其它强连通子图的子图
		13. 生成树：所谓连通图G的生成树(Spanning Tree)是指G的包含其全部顶点的一个极小连通子图。所谓极小连通子图是指在包含
					所有顶点并且保证连通的前提下包含原图中最少的边。一棵具有n个顶点的连通图G的生成树有且仅有n-1条边，如果
					少一条边就不是连通图，如果多一条边就一定有环。但是，有n-1条边的图不一定是生成树。
		14. 生成森林：在非连通图中，由每个连通分量都可得到一个极小连通子图，即一棵生成树。这些连通分量的生成树就组成了一个
					  非连通图的生成森林(Spanning Forest)。

2. 存储结构
	1. 邻接矩阵
		1. 定义：用两个数组来表示图，一个数组是一维数组，存储图中顶点的信息，一个数组是二维数组，即矩阵，存储顶点之间相邻的
			     信息，也就是边（或弧）的信息
	2. 邻接表
3. 图的遍历
	1. 深度优先遍历
	2. 广度优先遍历
4. 应用 
	1. 最小生成树
	2. 最短路径
	3. 拓扑排序
	
			
			
			
			
			
			
			
			
			
		